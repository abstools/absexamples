module FredhopperCloudServices;

export *;
import * from ABS.DC;
import * from ABS.SmartDeploy;
import Monitor from GenericMonitor;
import DegradationMonitorIf, DegradationMonitorImpl from DegradationView;

//abstraction for a customer
type Customer = String;

//abstraction for an identifier
type Id = Int;
def Id init() = 1;
def Id incr(Id id) = id + 1;

//abstraction for a request
type Request = Int;
def Int cost(Request request) = request;

//abstraction for a response
type Response = Bool;
def Response success() = True;
def Bool isSuccess(Response response) = response; 

//There exists an enumerated number of service types... 
data ServiceType = FAS | SUGGEST | DM;

// A Service configuration defines 
// * serviceType -- the type of service offered
// * instances -- the amount of resources each instance consumes
data Config = Config(ServiceType serviceType, List<ResourceCapacities> instances);

// Process state
data State = RUNNING | STOP;

//find last key (if any) that maps to e
def Maybe<X> mapValue<X, A>(Map<X, A> ss, A e) =
  case ss {
    EmptyMap => Nothing;
    InsertAssoc(p, y) => 
      case p {
      	Pair(x, e) => Just(x);
      	_ => mapValue(y, e);  
      };
  };

//remove the first occurence of v in list 
def List<X> removeFirst<X>(List<X> list, X v) =
	case list {
		Nil => Nil;
		Cons(v,vs) => vs;
		Cons(x,vs) => Cons(x, removeFirst(vs, v));
	};
  
//check if there is at least one occurence of v in list 
def Bool inList<X>(List<X> list, X v) =
	case list {
		Nil => False;
		Cons(v, vs) => True;
		Cons(_, vs) => inList(vs, v);
	};
	
//check if list contains only unique elements
def Bool unique<X>(List<X> list) =
	case list {
		Nil => True;
		Cons(v, vs) => if inList(vs, v) then False else unique(vs);
	};

//add v to list if v is not in list
def List<X> add<X>(List<X> list, X v) = 
	if inList(list, v) then list else Cons(v, list);
	
//Enumeration of VM types
data VMType =
	  T2_MICRO
	| T2_SMALL
	| T2_MEDIUM
	| M4_LARGE
	| M4_XLARGE
	| M4_2XLARGE
	| M4_10XLARGE
	| M3_MEDIUM
	| M3_LARGE
	| M3_XLARGE
	| M3_2XLARGE
	| C4_LARGE
	| C4_XLARGE
	| C4_2XLARGE
	| C4_4XLARGE
	| C4_8XLARGE;

def Set<VMType> vmTypesCollection() = set[
	  T2_MICRO,
	  T2_SMALL,
	  T2_MEDIUM,
	  M4_LARGE,
	  M4_XLARGE,
	  M4_2XLARGE,
	  M4_10XLARGE,
	  M3_MEDIUM,
	  M3_LARGE,
	  M3_XLARGE,
	  M3_2XLARGE,
	  C4_LARGE,
	  C4_XLARGE,
	  C4_2XLARGE,
	  C4_4XLARGE,
	  C4_8XLARGE];

	
type ResourceCapacities = Map<Resourcetype, Rat>;

//Given a VM type, return the capacity of each resource type in that VM
def ResourceCapacities vmResources(VMType v) = 
	case v {
		T2_MICRO => map[Pair(Memory,1), Pair(Speed,1)];
		T2_SMALL => map[Pair(Memory,2), Pair(Speed,1)];
		T2_MEDIUM => map[Pair(Memory,4), Pair(Speed,2)];
		M4_LARGE => map[Pair(Memory,8), Pair(Speed,2)];
		M4_XLARGE => map[Pair(Memory,16), Pair(Speed,4)];
		M4_2XLARGE => map[Pair(Memory,32), Pair(Speed,8)];
		M4_10XLARGE => map[Pair(Memory,160), Pair(Speed,40)];
		M3_MEDIUM => map[Pair(Memory,3750/1000), Pair(Speed,1)];
		M3_LARGE => map[Pair(Memory,7500/1000), Pair(Speed,2)];
		M3_XLARGE => map[Pair(Memory,15), Pair(Speed,4)];
		M3_2XLARGE => map[Pair(Memory,30), Pair(Speed,8)];
		C4_LARGE => map[Pair(Memory,3750/1000), Pair(Speed,2)];
		C4_XLARGE => map[Pair(Memory,7500/1000), Pair(Speed,4)];
		C4_2XLARGE => map[Pair(Memory,15), Pair(Speed,8)];
		C4_4XLARGE => map[Pair(Memory,30), Pair(Speed,16)];
		C4_8XLARGE => map[Pair(Memory,60), Pair(Speed,36)];
	};

def Map<String, ResourceCapacities> amazonInstances() =
		map[Pair("T2_MICRO", map[Pair(Memory,1), Pair(Speed,1)]),
		    Pair("T2_SMALL", map[Pair(Memory,2), Pair(Speed,1)]),
		    Pair("T2_MEDIUM", map[Pair(Memory,4), Pair(Speed,2)]),
		    Pair("M4_LARGE", map[Pair(Memory,8), Pair(Speed,2)]),
		    Pair("M4_XLARGE", map[Pair(Memory,16), Pair(Speed,4)]),
		    Pair("M4_2XLARGE", map[Pair(Memory,32), Pair(Speed,8)]),
		    Pair("M4_10XLARGE", map[Pair(Memory,160), Pair(Speed,40)]),
		    Pair("M3_MEDIUM", map[Pair(Memory,3750/1000), Pair(Speed,1)]),
		    Pair("M3_LARGE", map[Pair(Memory,7500/1000), Pair(Speed,2)]),
		    Pair("M3_XLARGE", map[Pair(Memory,15), Pair(Speed,4)]),
		    Pair("M3_2XLARGE", map[Pair(Memory,30), Pair(Speed,8)]),
		    Pair("C4_LARGE", map[Pair(Memory,3750/1000), Pair(Speed,2)]),
		    Pair("C4_XLARGE", map[Pair(Memory,7500/1000), Pair(Speed,4)]),
		    Pair("C4_2XLARGE", map[Pair(Memory,15), Pair(Speed,8)]),
		    Pair("C4_4XLARGE", map[Pair(Memory,30), Pair(Speed,16)]),
		    Pair("C4_8XLARGE", map[Pair(Memory,60), Pair(Speed,36)])
                ];



//type declarations in grammar
interface DeployerIF {
	Unit scaleUp();
	Unit scaleDown();
}

class DeployerImpl() implements DeployerIF {
	Unit scaleUp() { }
	Unit scaleDown() { }
}


//  Models an infrastructure service that allows one to acquire and release virtual machines
interface InfrastructureService {
	DC acquireInstance(Id id, VMType vmType);
	Unit release(DC component);
}


class InfrastructureServiceImpl(CloudProvider cp) implements InfrastructureService {
	
	Int total = 0;
	Map<Id, DC> inUse = EmptyMap;
	
	Int cpu(DC dc) {
		Fut<InfRat> cf = dc!total(Speed);
		InfRat cpu = cf.get;
		return truncate(finvalue(cpu));
	}
	
	DC acquireInstance(Id id, VMType vmType) {
		DC vm = null;
		ResourceCapacities resourceConfig = vmResources(vmType);
		Maybe<DC> md = lookup(inUse, id);
		case md {
			Nothing => {
				//Launch and acquire a new instance of type vmType
				vm = await cp!launchInstanceNamed(toString(vmType));
				//vm = new DeploymentComponent(intToString(id), resourceConfig);
				//TODO update total
				inUse = InsertAssoc(Pair(id, vm), inUse);
			}
			Just(d) => {
				//Use existing instance with the specified id
				vm = d;
			}
		}
		return vm;
	}
	
	Unit release(DC component) {
		Maybe<Int> id = mapValue(inUse, component);
		assert id != Nothing;
		inUse = removeKey(inUse, fromJust(id));
		Int cpu = this.cpu(component);
		total = total - cpu;
	}
}

// An endpoint is where service user connects to a service
interface EndPoint {
	Response invoke(Request request);
	Unit setStatus(State status);
	State getStatus();
}

interface LoadBalancerEndPoint extends EndPoint {
	//bring service instance off from load balancer
	Bool remove(Service service);
	//bring service instance on to load balancer
	Bool add(Service service);
	//return service instances used by load balancer
	List<Service> getServices();
}

// A service instance offers a single end point 
// A service has a service type, defining the kind of service offered
// A service belong to a customer
// A service exposes logging information
interface Service extends EndPoint {
	Id getServiceId();
	Unit setServiceId(Id id);
	ServiceType getServiceType();
	Customer getCustomer();
	Int getLatency();
	Int getRequestCount();
	Int getCPU();
	Int getBandwidth();
	Int getMemory();
	InfRat getResource(Resourcetype t);
}

// load balance over n services in round robin style
[Deploy: scenario[Cost("Cores", 2), Cost("Memory", 400), Param("Service", OptList("add"))]]
class LoadBalancerEndPointImpl implements LoadBalancerEndPoint {

	Int log = 0;
	State state = STOP;
	List<Service> services = Nil;
	List<Service> current = Nil;
	
	{
		assert unique(services);
	}

	Bool remove(Service service) {
		assert length(services) > 1;
		Bool result = False;	
		if (inList(services, service)) {
			services = removeFirst(services, service);
			current = removeFirst(current, service);
			result = True;
		}
		return result;
	}
	
	Bool add(Service service) {
		Bool result = False;	
		if (~inList(services, service)) {
			services = Cons(service, services);
			current = Cons(service, services);
			result = True;
		}
		return result;
	}

	Response invoke(Request request) {
		log = log + 1;
		assert state == RUNNING;
		if (current == Nil) {
			current = services;
		}
		EndPoint p = head(current);
		current = tail(current);
		return await p!invoke(request);
	}
	
	Unit setStatus(State status) {
		state = status;
	}
	
	State getStatus() {
		return state;
	}

	List<Service> getServices() {
		return current;
	}
}

class ServiceImpl(Id serviceId, ServiceType st, Customer c, Int cost) implements Service {
	Int latency = 0;
	Int log = 0;
	State state = STOP;
	
	Int getCPU() {
		DeploymentComponent dc = thisDC();
		Fut<InfRat> fdt = dc!total(Speed);
		InfRat dt = fdt.get;
		return truncate(finvalue(dt));
	}
	
	Int getBandwidth() {
		DeploymentComponent dc = thisDC();
		Fut<InfRat> fdt = dc!total(Bandwidth);
		InfRat dt = fdt.get;
		return truncate(finvalue(dt));
	}
	
	Int getMemory() {
		DeploymentComponent dc = thisDC();
		Fut<InfRat> fdt = dc!total(Memory);
		InfRat dt = fdt.get;
		return truncate(finvalue(dt));
	}
	
	InfRat getResource(Resourcetype t) {
		DeploymentComponent dc = thisDC();
		Fut<InfRat> fdt = dc!total(t);
		InfRat dt = fdt.get;
		return dt;
	}
	
	Int getLatency() {
		return latency;
	}
	
	Int getRequestCount() {
		return log;
	}

	State getStatus() {
		return state;
	}
	
	Unit setStatus(State state) {
		this.state = state;	
	}

	Id getServiceId() {
		return serviceId;
	}

	Unit setServiceId(Id id) {
		// ensure serviceId was not set previously
		assert serviceId == 0;

		serviceId = id;
	}
	
	Response invoke(Request request) {
		assert state == RUNNING;
		Int cost = cost(request);
		Int time = currentms();
		[Cost: cost] log = log + 1;
		time = currentms() - time;
		latency = max(latency, time); 
		return success();
	}

	ServiceType getServiceType() { 
		return st;
	}

	Customer getCustomer() {
		return c;
	}
	
}

// A deployment service creates or removes an instance of a specified servicetype
// and installs it onto a virtual machine (deployment component) of the specified type
interface DeploymentService {
	Service install(Customer customer, ServiceType st, Id serviceId, VMType v);
	Unit uninstall(Id serviceId);
	Unit start(Id serviceId);
	Unit stop(Id serviceId);
	Unit add(DeploymentAgent agent);
} 

// A deployment agent creates or removes an instance of a specified servicetype
// and installs it onto a virtual machine (deployment component) of the specified type
interface DeploymentAgent {
	Unit install(Service s);
	Unit uninstall();
	Unit start();
	Unit stop();
	Service getService();
}

[Deploy: scenario[Cost("Cores", 1), Cost("Memory", 80), Param("DeploymentServiceImpl", OptList("add")),
	Param("Service", OptList("install"))]]
class DeploymentAgentImpl implements DeploymentAgent {
	Service service = null;

	Unit install(Service s) {
		//ensure no service is currently installed
		assert service == null;
		assert s != null;

		// check that service is stopped
		State state = await s!getStatus();
		assert state == STOP;

		// install service
		service = s;
	}
	
	Unit uninstall() {
		// ensure a service is installed
		assert service != null;

		// check that service is stopped
		State state = await service!getStatus();
		assert state == STOP;

		// remove service
		service = null;
	}
	
	Unit start() {
		await service!setStatus(RUNNING);
	}
	
	Unit stop() {
		await service!setStatus(STOP);
	}

	Service getService() {
		return service;
	}
}

[Deploy: scenario[Cost("Cores", 1), Cost("Memory", 10), Param("DeploymentAgent", OptList("add"))]]
class DeploymentServiceImpl implements DeploymentService {

	Map<Service, DeploymentAgent> allocations = EmptyMap;
	Map<Id, Service> services = EmptyMap;

	/** Create a service of type st and deploy it on virtual machine with the given type
	 * @param customer The customer for which the service is deployed
	 * @param st The type of the service
	 * @param serviceId A unique identity of the service instance to be created
	 * @param v The type of virtual machine on which to deploy the service
    */
	Service install(Customer customer, ServiceType st, Id serviceId, VMType v) {
		assert lookup(services, serviceId) == Nothing;
		
		//instantiate service
		//base query costs at least 2 time units
		Service service = new ServiceImpl(serviceId, st, customer, 2);
		// install service using new deployment agent
		DeploymentAgent agent = new DeploymentAgentImpl();
		await agent!install(service);
		
		allocations = InsertAssoc(Pair(service, agent), allocations);
		services = InsertAssoc(Pair(serviceId, service), services);
		return service;
	}
	
	Service lookup(Id id) {
		Maybe<Service> s = lookup(services, id);
		assert s != Nothing;
		return fromJust(s);
	}
	
	Unit uninstall(Id serviceId) {
		Service service = this.lookup(serviceId);
		State state = await service!getStatus();
		assert state == STOP;

		Maybe<DeploymentAgent> mAgent = lookup(allocations, service);
		assert mAgent != Nothing;
		DeploymentAgent agent = fromJust(mAgent);

		await agent!uninstall();
		
		allocations = removeKey(allocations, service);
		services = removeKey(services, serviceId);
	}
	
	Unit invoke(Id serviceId, State state) {
		Service service = this.lookup(serviceId);
		await service!setStatus(state);
	}
	
	Unit start(Id serviceId) {
		this.invoke(serviceId, RUNNING);
	}
	
	Unit stop(Id serviceId) {
		this.invoke(serviceId, STOP);
	}

	Unit add(DeploymentAgent agent) {
		// get service deployed using agent
		Service s = await agent!getService();

		// get service Id
		Id serviceId = await s!getServiceId();
		assert serviceId != 0;

		allocations = InsertAssoc(Pair(s, agent), allocations);
		services = InsertAssoc(Pair(serviceId, s), services);

		this.start(serviceId);
	}
}

// A load balancer service distributes request over service instances
// A load balancer can enable or disable a service
interface LoadBalancerService {
	Bool disable(Id endPointId);
	Bool enable(Id endPointId);
	//creates a new LB endpoint with the specified id
	//and connects it to the specified service instances
	Bool create(List<Service> services, Int endPointId);
	//add the LB endpoint ep with endPointId
	Bool add(Int endPointId, LoadBalancerEndPoint ep);
	//remove the endpoint with the given endPointId
	Bool remove(Id endPointId);
	//get (if any) the id of the specified endpoint
	Maybe<Id> getEndPointId(LoadBalancerEndPoint lb);
	//get (if any) the endpoint with endPointId
	Maybe<LoadBalancerEndPoint> getEndPointById(Int endPointId);
	//get all endpoints that use the service s
	List<Id> getEndPointIdsByService(Service s);
	//take service off load balancing
	Bool decrease(Id endPointId, List<Service> services);
	//put service on load balancing 
	Bool increase(Id endPointId, List<Service> services);
}

//enum to specify whether to increase/decrease load balance resource
data LBOp = INCR | DECR;

[Deploy: scenario[Cost("Cores", 1), Cost("Memory", 10)] ]
class LoadBalancerServiceImpl implements LoadBalancerService {

	//1-1 map from end point id to end point
	Map<Int, LoadBalancerEndPoint> endPoints = EmptyMap;
	
	Bool change(Id endPointId, List<Service> services, LBOp op) {
		Bool result = False;
		Maybe<LoadBalancerEndPoint> ep = lookup(endPoints, endPointId);
		if (ep != Nothing) {
			LoadBalancerEndPoint endPoint = fromJust(ep);
			while (services != Nil) {
				Fut<Bool> fb;
				if (op == INCR) {
					fb = endPoint!add(head(services));
				} else {
					fb = endPoint!remove(head(services));
				}
				Bool b = fb.get; 
				result = result || b; 
				services = tail(services);
			}
		}
		return result;
	}
	
	Bool decrease(Id endPointId, List<Service> services) {
		Bool result = this.change(endPointId, services, DECR);
		return result;
	}
	
	Bool increase(Id endPointId, List<Service> services) {
		Bool result = this.change(endPointId, services, INCR);
		return result;
	}

	Bool status(Id id, State state) {
		Maybe<EndPoint> mep = lookup(endPoints, id);
		Bool success = False;
		if (mep != Nothing) {
			EndPoint point = fromJust(mep);
			await point!setStatus(state);
			success = True;	
		}
		return success;
	}

	Bool disable(Id id) {
		return this.status(id, STOP);
	}
	
	Bool enable(Id id) {
		return this.status(id, RUNNING);	
	}
	
	Bool create(List<Service> services, Int endPointId) {
		Bool added = False;
		Maybe<EndPoint> mep = lookup(this.endPoints, endPointId);
		if (mep == Nothing) {
			LoadBalancerEndPoint ep = new LoadBalancerEndPointImpl();
			while(services != Nil) {
				Service s = head(services);
				await ep!add(s);
				services  = tail(services);
			}
			endPoints = put(endPoints, endPointId, ep);
			added = True;
		}
		return added;
	}

	Bool add(Int endPointId, LoadBalancerEndPoint ep) {
		Bool added = False;
		Maybe<EndPoint> mep = lookup(this.endPoints, endPointId);
		if (mep == Nothing) {
			endPoints = put(endPoints, endPointId, ep);
			added = True;
		}
		return added;
	}
	
	Bool remove(Id endPointId) {
		Bool removed = False;
		Maybe<EndPoint> mep = lookup(this.endPoints, endPointId);
		if (mep != Nothing) {
			EndPoint point = fromJust(mep);
			State state = await point!getStatus();
			assert state == STOP;
			this.endPoints = removeKey(this.endPoints, endPointId);
			removed = True;
		}
		return removed;
	}
	
	Maybe<LoadBalancerEndPoint> getEndPointById(Id endPointId) {
		return lookup(endPoints, endPointId);
	}

	List<Id> getEndPointIdsByService(Service s) {
		List<LoadBalancerEndPoint> endPointsToCheck = values(endPoints);
		List<Id> foundEndPoints = Nil;

		while(endPointsToCheck != Nil) {
			LoadBalancerEndPoint lb = head(endPointsToCheck);

			//get services used by load balancer lb
			List<Service> services = await lb!getServices();

			if(inList(services, s)) {
				Maybe<Id> mep = mapValue(endPoints, lb);
				case mep {
					Nothing => {
						foundEndPoints = Nil;
					}
					Just(id) => {
						foundEndPoints = Cons(id, foundEndPoints);
					}
				}
			}
			endPointsToCheck = tail(endPointsToCheck);
		}

		return foundEndPoints;
	}

	Maybe<Id> getEndPointId(LoadBalancerEndPoint lb) {
		return mapValue(endPoints, lb);
	}
}


//Platform service can create and remove a service
interface PlatformService {
	//return end point id
	Id createService(Config config, Customer customer);
	Unit removeService(Id endPoint);
	
}

//Platform service used by monitor to scale up/down a service
interface MonitorPlatformService extends PlatformService {
	//increase the number of service instances by n
	Unit incrService(Id endPoint, List<ResourceCapacities> instances);
	//decrease the number of service instances by n
	Unit decrService(Id endPoint, List<Id> serviceIds);
	//all existing endpoints 
	List<Id> getEndPoints();
	//service instance with the given id
	Maybe<Service> getService(Id serviceId);
	//service instance ids of all 'deployed' service instances referred by the given endPoint
	List<Id> getServiceIds(Id endPoint);
	//alter the cpu resource of serviceId underlying resource by r
	Unit alterResource(Id serviceId, Resourcetype t, Rat r);
	//add end point
	Id addEndPoint(LoadBalancerEndPoint lb);
	//remove end point
	Id removeEndPoint(LoadBalancerEndPoint lb);
	//add service instance
	Id addServiceInstance(Service s);
}

def List<X> toList<X>(Set<X> s) =
	case s {
		EmptySet => Nil;
		Insert(x, xs) => Cons(x, toList(xs));
	};

def Maybe<Pair<Config, Int>> lookupService(Map<Config, Int> cs, ServiceType s) =
	case cs {
		EmptyMap => Nothing;
		InsertAssoc(Pair(Config(s, ls), e), _) => Just(Pair(Config(s, ls), e));
		InsertAssoc(_, ms) => lookupService(ms, s);
	};   

def Maybe<Pair<Config, Int>> lookupCustomerService(Map<Customer, Map<Config, Int>> cs, Customer c, ServiceType s) =
	case lookupDefault(cs, c, EmptyMap) {
		EmptyMap => Nothing;
		map => lookupService(map, s);
	};
	
def Map<Config, Int> removeLocalEndPoint(Map<Config, Int> cs, Int e) = 
	case cs {
		EmptyMap => EmptyMap;
		InsertAssoc(Pair(_,e), cs) => cs;
		InsertAssoc(kv, ms) => InsertAssoc(kv, removeLocalEndPoint(ms, e));
	};
	
	
def Map<Customer, Map<Config, Int>> removeGlobalEndPoint(Map<Customer, Map<Config, Int>> cs, Int e) =
	case cs {
		EmptyMap => EmptyMap;
		InsertAssoc(Pair(c, map), cs) => 
			case removeLocalEndPoint(map, e) {
				EmptyMap => removeGlobalEndPoint(cs, e);
				newMap => InsertAssoc(Pair(c, newMap), removeGlobalEndPoint(cs, e)); 
			};
	};
	
def Maybe<Pair<X, Y>> keyPairs<X, Y, Z>(Map<X, Map<Y, Z>> map, Z z) =
	case map {
		EmptyMap => Nothing;
		InsertAssoc(Pair(x, cm), ms) =>
			case mapValue(cm, z) {
				Nothing => keyPairs(ms, z);
				Just(y) => Just(Pair(x, y));
			};
	};
	
def Map<Customer, Map<Config, Int>> updateConfig(Map<Customer, Map<Config, Int>> cs, Customer c, Config o, Config n) =
	case lookup(cs, c) {
		Nothing => cs;
		Just(cm) => 
			case lookup(cm, o) {
				Nothing => cs;
				Just(e) => put(cs, c, put(removeKey(cm, o), n, e)); 
			}; 
	};
	
def List<X> take<X>(List<X> ls, Int n) =
	case ls {
		Nil => Nil;
		Cons(x, xs) => if n == 0 then Nil else Cons(x, take(xs, n - 1));
	};

def A takeFromSet<A>(Set<A> ss) =
  case ss {
    Insert(e, _) => e;
  };
	
def Bool inListAll<X>(List<X> ls, List<X> ms) = 
	case ms {
		Nil => True;
		Cons(m, mm) => inListAll((if inList(ls, m) then removeFirst(ls, m) else ls), mm);   
	}; 
	
def List<X> removeAllinList<X>(List<X> ls, List<X> ms) = 
	case ms {
		Nil => Nil;
		Cons(m, mm) => removeAllinList(without(ls, m), mm);   
	}; 
	
def Map<X, Y> removeAll<X, Y>(Map<X, Y> map, List<X> xs) =
	case xs {
		Nil => map;
		Cons(x, nx) => removeAll(removeKey(map, x), nx);
	};
	
def List<X> difference<X>(List<X> xs, List<X> ys) =
	case ys {
		Nil => Nil;
		Cons(y, ny) => difference(without(xs, y), ny);
	};
	
def List<Y> lookupMap<X, Y>(Map<X, Y> map, List<X> xs) =
	case xs {
		Nil => Nil;
		Cons(x, nx) => 
			case lookup(map, x) {
				Nothing => lookupMap(map, nx);
				Just(v) => Cons(v, lookupMap(map, nx));
			};
	};
	
def List<Z> lookupTwoMaps<X, Y, Z>(Map<X, List<Y>> m1, Map<Y, Z> m2, X x) =
	case lookup(m1, x) {
		Nothing => Nil;
		Just(vs) => lookupMap(m2, vs);
	};


[Deploy: scenario[Cost("Cores", 2), Cost("Memory", 1200), Param("ds", Req),Param("ls", Req),Param("LoadBalancerEndPoint", OptList("addEndPoint")),Param("Service", OptList("addServiceInstance"))]]
class PlatformServiceImpl(DeploymentService ds, LoadBalancerService ls) 
implements MonitorPlatformService {

	// service instance id to service instance
	Map<Id, Service> services = EmptyMap;
	
	// service instance id to end point id
	Map<Id, Int> serviceToEndPoints = EmptyMap;
	
	// end point id to service instance id
	Map<Id, List<Id>> endPoints = EmptyMap;
	
	//customer setting to endpoint ids
	Map<Customer, Map<Config, Id>> customers = EmptyMap;
	
	//Id of next-to-be-created service
	Id serviceId = init();
	
	Id createService(Config config, Customer customer) {
		//this customer cannot already have the same service deployed
		ServiceType st = serviceType(config);
		assert lookupCustomerService(customers, customer, st) == Nothing;
	
		List<ResourceCapacities> instances = instances(config);
		//number of instances must be positive
		assert instances != Nil;
		
		//endpoint id
		serviceId = incr(serviceId);
		Int endPoint = serviceId;
		
		//create service instances
		List<Service> currentServices = Nil;
		List<Id> ids = Nil;
		
		while (instances != Nil) {
			ResourceCapacities res = head(instances);
			Service service = this.createServiceInstance(customer, st, res);
			Fut<Id> idf = service!getServiceId();
			Id id = idf.get;
			ids = Cons(id, ids);
			serviceToEndPoints = InsertAssoc(Pair(id, endPoint), serviceToEndPoints);
			currentServices = Cons(service, currentServices);
			instances = tail(instances);
		}
		
		//associate endpoint with service instances
		endPoints = InsertAssoc(Pair(endPoint, ids), endPoints);
		
		//update customer record
		customers = put(customers, customer, put(lookupDefault(customers, customer, EmptyMap), config, endPoint));
		
		//create new load balancer and connect services to it
		await ls!create(currentServices, endPoint);
		
		//enable service
		await ls!enable(endPoint);
		
		return endPoint;
	}
	
	Unit removeService(Int endPoint) {
		//disable end point 
		Bool b = await ls!disable(endPoint); 
		assert b;
		
		//remove from load balancer
		b = await ls!remove(serviceId);
		assert b;
		
		//remove service instance
		List<Id> sids = lookupDefault(endPoints, endPoint, Nil); 
		while (sids != Nil) {
			Id id = head(sids);
		
			//remove from map
			services = removeKey(services, id);
			serviceToEndPoints = removeKey(serviceToEndPoints, id);
			
			//stop it
			await ds!stop(id);
			await ds!uninstall(id);
			
			sids = tail(sids);	
		}
		
		//remove from customer record
		endPoints = removeKey(endPoints, endPoint);
		customers = removeGlobalEndPoint(customers, endPoint);
	}


	/* This method should be called _after_ service is added to load balancer endpoint */
	Id addServiceInstance(Service s) {
		//generate new service instance id
		serviceId = incr(serviceId);
		Id id = serviceId;

		//set the id in the service instance
		await s!setServiceId(id);

		//insert into id-to-services map
		services = put(services, id, s);

		//get id's of endpoints that use this service instance
		List<Id> onEndPoints = await ls!getEndPointIdsByService(s);

		List<Id> endPointsToProcess = onEndPoints;
		while(endPointsToProcess != Nil) {
			Id endPointId = head(endPointsToProcess);

			// update maps with service-endpoint relation
			serviceToEndPoints = InsertAssoc(Pair(id, endPointId), serviceToEndPoints);
			Maybe<List<Id>> mSerEndpoints = lookup(endPoints, endPointId);
			case mSerEndpoints {
				Nothing => {
					endPoints = InsertAssoc(Pair(endPointId, list[id]), endPoints);
				}
				Just(l) => {
					endPoints = InsertAssoc(Pair(endPointId, Cons(id, l)), endPoints);
				}
			}
			
			endPointsToProcess = tail(endPointsToProcess);
		}
		
		return serviceId;
	}

	Id addEndPoint(LoadBalancerEndPoint lb) {
		//generate id for the endpoint
		serviceId = incr(serviceId);
		Int endPoint = serviceId;

		//find service instances connected to the endpoint
		List<Service> connectedServices = await lb!getServices();

		// update endPoints and serviceToEndPoints maps
		List<Service> remaining = connectedServices;
		while(remaining != Nil) {
			Service s = head(remaining);
			Id serviceId = await s!getServiceId();

			//update serviceToEndPoints
			serviceToEndPoints = put(serviceToEndPoints, serviceId, endPoint);

			//update endPoints
			List<Id> connectedIds = lookupDefault(endPoints, endPoint, Nil);
			connectedIds = Cons(serviceId, connectedIds);
			endPoints = put(endPoints, endPoint, connectedIds);
		}

		//add the endpoint to the LB service with the generated id
		await ls!add(endPoint, lb);

		//enable the endpoint in the LB service
		await ls!enable(endPoint);
		return endPoint;
	}

	Id removeEndPoint(LoadBalancerEndPoint lb) {
		// TODO
		return 0;
	}
	
	Service createServiceInstance(Customer customer, ServiceType st, ResourceCapacities resource) {
		serviceId = incr(serviceId);
		
		Id id = serviceId;

		// Select a VM that satisfies the given resource requirements
		Set<VMType> vms = this.findVM(resource);
		assert ! emptySet(vms);
		VMType v = takeFromSet(vms);
 
		//register with deployment service and appropriate VM
		Fut<Service> sf = ds!install(customer, st, id, v);
		Service service = sf.get;
		
		//start instance
		Fut<Unit> uf = ds!start(id); sf.get;
		
		//update record
		services = put(services, id, service);
		
		return service;
	} 
	
	Unit incrService(Id endPoint, List<ResourceCapacities> instances) {
		 assert instances != Nil;
	
		 Maybe<Pair<Customer, Config>> setting = keyPairs(customers, endPoint);
		 assert setting != Nothing;
		 
		 Customer customer = fst(fromJust(setting)); 
		 Config oldC = snd(fromJust(setting));
		 
		 ServiceType st = serviceType(oldC);
		 
		 //install and start a new service instance
		 List<Service> es = Nil;
		 List<Id> ids = Nil;
		 List<ResourceCapacities> remaining = instances;
		 while (remaining != Nil) {
		 	ResourceCapacities res = head(remaining);
		 	Service service = this.createServiceInstance(customer, st, res);
		 	
		 	//get the service instance id
		 	Fut<Int> idf = service!getServiceId();
		 	Id id = idf.get;
		 	
		 	//update record
		 	serviceToEndPoints = InsertAssoc(Pair(id, endPoint), serviceToEndPoints);
			ids = Cons(id, ids);
		 	es = Cons(service, es);
		 	remaining = tail(remaining);
		 }
		 
  	 	 //update record
	 	 endPoints = put(endPoints, endPoint, concatenate(ids, lookupDefault(endPoints, endPoint, Nil)));

		 //add to load balancer
		 Fut<Bool> fb = ls!increase(endPoint, es); 
		 Bool increased = fb.get;
		 assert increased;
		 
		 //update record
		 customers = updateConfig(customers, customer, oldC, Config(st, concatenate(instances, instances(oldC))));
	}
	
	Unit decrService(Id endPoint, List<Id> serviceIds) {
		Maybe<Pair<Customer, Config>> setting = keyPairs(customers, endPoint);
		assert setting != Nothing;
		
		Customer customer = fst(fromJust(setting)); 
		Config oldC = snd(fromJust(setting));
		
		ServiceType st = serviceType(oldC);
		
		Maybe<List<Id>> msers = lookup(endPoints, endPoint);
		assert msers != Nothing;
		
		//cannot scale down to 0 instance
		//or can we?... 
		List<Id> sers = fromJust(msers);
		assert inListAll(sers, serviceIds);
		
		List<Service> deployed = Nil;
		List<Id> remains = serviceIds;
		while (remains != Nil) {
			Id serviceId = head(remains); 
			Maybe<Service> mdeployed = lookup(services, serviceId);
			assert mdeployed != Nothing;
			deployed = Cons(fromJust(mdeployed), deployed);
			remains = tail(remains);
		}

		//remove from load balancer
		Fut<Bool> fb = ls!decrease(endPoint, deployed); 
		Bool decreased = fb.get;
		assert decreased;

		//uninstall
		remains = serviceIds;
		List<ResourceCapacities> current = instances(oldC);
		while (remains != Nil) {
			Id serviceId = head(remains); 
			Fut<Unit> sf = ds!stop(serviceId); sf.get;
			sf = ds!uninstall(serviceId); sf.get;
	
			//update record
			serviceToEndPoints = removeKey(serviceToEndPoints, serviceId);
			services = removeKey(services, serviceId);
			remains = tail(remains);
			current = tail(current);
		} 
		
		//update record
		endPoints = put(endPoints, endPoint, difference(lookupDefault(endPoints, endPoint, Nil), serviceIds));
		customers = updateConfig(customers, customer, oldC, Config(st, current));
	}
	
	Unit uninstallInstance(Id endPoint, Service s, Id serviceId) {
		//remove from load balancer
		Fut<Bool> bf = ls!decrease(endPoint, list[s]); bf.get;
			
		//stop service
		Fut<Unit> uf = ds!stop(serviceId); uf.get;
			 
		//uninstall service
		uf = ds!uninstall(serviceId); uf.get;
	}
	
	Unit alterResource(Id serviceId, Resourcetype t, Rat r) {
		Maybe<Service> mservice = lookup(services, serviceId);
		assert mservice != Nothing;
		Service ser = fromJust(mservice);
		
		// Compute new capacity of the resource
		Fut<InfRat> fOldCapacity = ser!getResource(t);
		InfRat oldCapacity = fOldCapacity.get;
		assert oldCapacity != InfRat;
		Rat newCapacity = 0;
		case oldCapacity {
			Fin(v) => {
				// increase old capacity by r
				newCapacity = v + r;
			}
		}
		// TODO: generalize to requirements on multiple resources.
		// Using map[Pair(t, newCapacity)] as resource requirements
		// chooses a random machine with newCapacity resources for
		// resourcetype t, but no requirements on the capacity of
		// the other resource types (so previous requirements are discarded)
		ResourceCapacities req = map[Pair(t, newCapacity)];
		
		
		Maybe<Int> mendPoint = lookup(serviceToEndPoints, serviceId);
		assert mendPoint != Nothing;
		
		Int endPoint = fromJust(mendPoint);
		
		List<Int> instances = lookupDefault(endPoints, endPoint, Nil);

		//create a new service, replacing the old one
		Fut<Customer> fc = ser!getCustomer(); 
		Customer customer = fc.get;
		
		Fut<ServiceType> fs = ser!getServiceType();
		ServiceType st = fs.get;
		
		Service newSer = this.createServiceInstance(customer, st, req);
		Fut<Int> idf = newSer!getServiceId();
		Int newId = idf.get;
		
		//add to load balancer
	 	Fut<Bool> fb = ls!increase(endPoint, list[newSer]);
	 	Bool increased = fb.get;
	 	assert increased;
	 	
		//update record
		serviceToEndPoints = InsertAssoc(Pair(newId, endPoint), serviceToEndPoints);
		List<Int> allInstances = Cons(newId, lookupDefault(endPoints, endPoint, Nil));
		
		//remove old instance
	 	this.uninstallInstance(endPoint, ser, serviceId);
	 	
	 	//update record
	 	serviceToEndPoints = removeKey(serviceToEndPoints, serviceId);
		services = removeKey(services, serviceId);
	 	endPoints = put(endPoints, endPoint, without(allInstances, serviceId));
	}
	
	List<Id> getEndPoints() {
		return toList(keys(endPoints)); 
	}
	
	List<Id> getServiceIds(Id endPoint) {
		return lookupDefault(endPoints, endPoint, Nil);
	}
	
	Maybe<Service> getService(Id serviceId) {
		return lookup(services, serviceId);
	}
	
	/** Returns a set of VM types, iterating over all
      * VM types defined in vmTypesCollection(), 
	  * that satisfy the given resource requirements 
	*/
	Set<VMType> findVM(ResourceCapacities rc2) {
		Set<VMType> remaining = vmTypesCollection();
		Set<VMType> res = EmptySet;
		while(!emptySet(remaining)) {
			VMType vm = takeFromSet(remaining);
			remaining = remove(remaining, vm);
			Bool match = this.matchResources(vmResources(vm), rc2);
			if(match) {
				res = insertElement(res, vm);
			}
		} 
		
		return res;
	}
	
	/** Determines whether resource config rc1 specifies at least equal capacity
	  * for every resource than resource config rc2 does, ignoring capacity of
      * resource types not present in both maps.
	*/
	Bool matchResources(ResourceCapacities rc1, ResourceCapacities rc2) {
	// Examples:
	// matchResources(map[Pair(Memory,1), Pair(CPU,1)], map[Pair(Memory,1), Pair(CPU,2)]); // False
	// matchResources(map[Pair(Memory,1), Pair(CPU,2)], map[Pair(Memory,1), Pair(CPU,1)]); // True
	// matchResources(map[Pair(Memory,1), Pair(CPU,1)], map[Pair(Memory,1), Pair(CPU,1)]); // True 
	// matchResources(map[Pair(Memory,1), Pair(CPU,1)], map[Pair(CPU,1)]); // True 
	// matchResources(map[Pair(Memory,1)], map[Pair(Memory,1), Pair(CPU,1)]); // True
        Bool result = True;
        Set<Resourcetype> resources1 = keys(rc1);
        while (result == True && !(emptySet(resources1))) {
            Resourcetype key = takeFromSet(resources1);
            resources1 = remove(resources1, key);
            Rat value1 = lookupUnsafe(rc1, key);
            Maybe<Rat> value2 = lookup(rc2, key);
            case value2 {
            	Nothing => {   
            		result = True; // ignore resource types without specified capacity
            	}
            	Just(v2) => {
            		if(value1 < v2) {
            			result = False;
            		}
            	}
            }
        }
        return result;
	}
}

interface User {
	Unit use(EndPoint endPoint, Int min, Int max);
}

//a user invokes a service endpoint repeatedly 
class RepeatUserImpl implements User {

	Int log = 0;
	
	Unit use(EndPoint endPoint, Int min, Int max) {
		Int count = 0;
		while (True) {
			State state = this.getState(endPoint);
			if (state == RUNNING) {
				log = log + 1;
				Response res = this.invoke(endPoint, min, max);
			}
		}
	}
	
	Response invoke(EndPoint point, Int min, Int max) {
		return this.invokeWithSize(point, min, max, 0);	
	}
	
	Response invokeWithSize(EndPoint point, Int min, Int max, Request request) {
		await duration(min, max);
		Fut<Response> bf = point!invoke(request);
		Response b = bf.get;
		return b;	
	}
	
	State getState(EndPoint point) {
		Fut<State> sf = point!getStatus();
		State state = sf.get;
		return state;
	}
}

data Rule = Rule(Int interval, Monitor monitor); 

def Map<X, Map<X, Y>> reset<X, Y>(Map<X, Map<X, Y>> map, X x) =
	case map {
		EmptyMap => EmptyMap;
		InsertAssoc(Pair(k, ns), ms) =>
			case lookup(ns, x) {
				Nothing => InsertAssoc(Pair(k, ns), reset(ms, x));
				Just(y) => InsertAssoc(Pair(k, put(removeKey(ns, x), k, y)), reset(ms, x));
			};
	};

def List<Y> lookupAllSecond<W, X, Y>(Map<W, Map<X, List<Y>>> map, X x) =
	case map {
		EmptyMap => Nil;
		InsertAssoc(Pair(w, ns), ms) => concatenate(lookupDefault(ns, x, Nil), lookupAllSecond(ms, x));
	};

//return the value from the pair-key-value map of the first pair-key whose first element is w, return d otherwise.  
def Y lookupFirstDefault<W, X, Y>(Map<Pair<W, X>, Y> map, W w, Y d) =
	case map {
		EmptyMap => d;
		InsertAssoc(Pair(Pair(w, _), y), _) => y;
		InsertAssoc(_, ms) => lookupFirstDefault(ms, w, d);
	};

def Map<Int, Y> decr1<Y>(Map<Int, Y> map) =
	case map {
		EmptyMap => EmptyMap;
		InsertAssoc(Pair(w, y), ms) => InsertAssoc(Pair(w - 1, y), decr1(ms)); 
	};
	
def Map<X, Map<Int, Y>> decr<X, Y>(Map<X, Map<Int, Y>> map) =
	case map {
		EmptyMap => EmptyMap;
		InsertAssoc(Pair(w, ns), ms) => InsertAssoc(Pair(w, decr1(ns)), decr(ms)); 
	};

def Map<Pair<W, X>, List<Y>> putTable<W, X, Y>(Map<Pair<W, X>, List<Y>> map, W w, X x, Y y) =
	put(map, Pair(w, x), Cons(y, (lookupFirstDefault(map, w, Nil))));
	
//remove the first (and should be only) occurence of key-value pair (x,y) from map 	
def Maybe<Pair<X, Y>> lookupFirstKey<X, Y, Z>(Map<Pair<X, Y>, Z> map, X x) =
	case map {
		EmptyMap => Nothing;
		InsertAssoc(Pair(Pair(x, y), _), _) => Just(Pair(x, y));
		InsertAssoc(_, ms) => lookupFirstKey(ms, x);
	};

interface MonitoringService {
	Unit add(Rule rule);
	Unit remove(Rule rule);
}

class MonitoringServiceImpl implements MonitoringService {

	Int log = 0;

	//map a interval-elapsed time pair to the corresponding scheduled map of executable monitor/action 
	Map<Int, Map<Int, List<Monitor>>> monitorMap = EmptyMap;
	
	Unit add(Rule rule) {
		Int interval = interval(rule);
		assert interval > 0;
		Monitor monitor = monitor(rule);
		
		Map<Int, List<Monitor>> thisInterval = lookupDefault(monitorMap, interval, EmptyMap);
		List<Monitor> monitors = lookupDefault(thisInterval, interval, Nil);
		monitorMap = put(monitorMap, interval, put(thisInterval, interval, Cons(monitor, monitors)));
	}
	
	Unit remove(Rule rule) {
		Int interval = interval(rule);
		Monitor monitor = monitor(rule);
		Map<Int, List<Monitor>> thisInterval = lookupDefault(monitorMap, interval, EmptyMap);
		Set<Int> keys = keys(thisInterval);
		
		Bool done = False;
		while (keys != EmptySet && ~done) {
			Pair<Set<Int>, Int> nt = next(keys);
			List<Monitor> monitors = lookupDefault(thisInterval, snd(nt), Nil);
			if (inList(monitors, monitor)) {
				monitorMap = put(monitorMap, interval, put(thisInterval, snd(nt), without(monitors, monitor)));
				done = True;
			} else {
				keys = fst(nt);
			}
		}
	}
	
	Unit run() {
		while (True) {
		
			// advance clock
			await duration(1, 1);
			
			log = log + 1;
			
			//count down
			monitorMap = decr(monitorMap);
			
			//find all to be run
			List<Monitor> toBeRun = lookupAllSecond(monitorMap, 0);
			
			//reset
			monitorMap = reset(monitorMap, 0);
		
			//execute monitors
			List<Fut<Unit>> futs = Nil;
			while (toBeRun != Nil) {
				Monitor mon = head(toBeRun);
				Fut<Unit> f = this!execute(mon);
				futs = Cons(f, futs);
				toBeRun = tail(toBeRun);
			}
			
			while (futs != Nil) {
				Fut<Unit> f = head(futs);
				await f?;
				f.get;
				futs = tail(futs);
			}
		}
	}
	
	Unit execute(Monitor monitor) {
		Fut<Unit> f = monitor!monitor();
		await f?;
		f.get;
	}
	
}

//A monitor that checks the latency of a service endpoint and scales CPU
class LatencyMonitor(Int upper, MonitorPlatformService ps) implements Monitor {
	
	Int log = 0;
	
	Int scaling(Service logger, Int latency) {
		Fut<Int> fcpu = logger!getCPU();
		Int cpu = fcpu.get;
		Rat amount = cpu * (latency - upper/latency);
		return max(1, truncate(amount));
	}
	
	List<Pair<Id, Int>> getLatencies(Int endPoint) {
		List<Pair<Id, Int>> scaling = Nil;
		Fut<List<Id>> fservices = ps!getServiceIds(endPoint);
		List<Id> services = fservices.get;
		while (services != Nil) {
			Id serviceId = head(services);
			Fut<Maybe<Service>> lf = ps!getService(serviceId);
			Maybe<Service> ml = lf.get;
			assert ml != Nothing;
			Service logger = fromJust(ml);
			Fut<Int> lif = logger!getLatency();
			Int latency = lif.get;
			if (latency > upper) {
				Int res = this.scaling(logger, latency);
				scaling = Cons(Pair(serviceId, res), scaling);
			}
			services = tail(services);
		}
		return scaling;
	}
	
	// Monitors latencies and accordingly scales CPU resources
	Unit monitor() {
		log = log + 1;
		List<Triple<Id, Resourcetype, Int>> scaling = Nil;
		Fut<List<Int>> ef = ps!getEndPoints();
		List<Int> endPoints = ef.get;
		while (endPoints != Nil) {
			Int endPoint = head(endPoints);
			List< Pair<Id, Int> > setting = this.getLatencies(endPoint);
			while(setting != Nil) {
				Pair<Id, Int> lat = head(setting);
				setting = tail(setting);
				Triple<Id, Resourcetype, Rat> h = Triple(fst(lat), Speed, snd(lat));
				scaling = Cons(h, scaling);
			}
			endPoints = tail(endPoints);
		}
		

		//Execute scaling action
		while (scaling != Nil) {
			Triple<Id, Resourcetype, Rat> sc = head(scaling);
			Id instance = fstT(sc);
			Resourcetype rt = sndT(sc);
			Rat v = trd(sc);
			Fut<Unit> fu = ps!alterResource(instance, rt, v); fu.get;
			scaling = tail(scaling);
		}
	}

	List< Pair<Time, List<Pair<String, Rat> > > > metricHistory() {
		return Nil;
	}
	
}


data Scale = UP | DOWN;

//scale up/down the number of instances according to the scaling setting
//scaling setting is a list of pairs of endpoint id to the number of instances to add/remove  
/*class ScaleInstanceAction(List<Triple<Int, Scale, List<Int>>> scalings, MonitorPlatformService ps) implements Action {
	
	Unit action() {
		while (scalings != Nil) {
			Triple<Int, Scale, List<Int>> scaling = head(scalings);
			Int endPoint = fstT(scaling);
			Scale scale = sndT(scaling);
			List<Int> instances = trd(scaling);
			if (scale == UP) {
				Fut<Unit> fu = ps!incrService(endPoint, instances); fu.get;
			} else {
				Fut<Unit> fu = ps!decrService(endPoint, instances); fu.get;
			}
			scalings = tail(scalings);
		}
	}
}*/

/**
	Models a cloud service provider such as Fredhopper
**/
interface ServiceProvider {
	EndPoint addCustomer(Config sc, Customer c);
	Unit removeCustomer(Config sc, Customer c);
}

[Deploy: scenario[Param("ps", Req), Param("ls", Req)] ]
class ServiceProviderImpl(PlatformService ps, LoadBalancerService ls) implements ServiceProvider {

	Map<Customer, Map<Config, Int>> customers = EmptyMap; 

	EndPoint addCustomer(Config sc, Customer c) {
		Int id = await ps!createService(sc, c);
		
		Map<Config, Int> map = lookupDefault(customers, c, EmptyMap);
		assert lookup(map, sc) == Nothing;
		
		customers = put(customers, c, InsertAssoc(Pair(sc, id), map));
		
		Fut<Maybe<EndPoint>> ef = ls!getEndPointById(id);
		Maybe<EndPoint> eps = ef.get;
		assert eps != Nothing;
		return fromJust(eps);
	}
	
	Unit removeCustomer(Config sc, Customer c) {
		Map<Config, Int> map = lookupDefault(customers, c, EmptyMap);
		Maybe<Int> mid = lookup(map, sc);
		assert mid != Nothing;
		
		//update map
		customers = put(customers, c, removeKey(map, sc));
		
		//remove from load balancer and platform etc.
		await ps!removeService(fromJust(mid)); 
	}

}




//////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Example of a service to deploy: query service of the Fredhopper Access Server 
*/
interface Item {
}

interface IQueryService extends Service {
	List<Item> doQuery(String q);
}

// Stub implementation of the query service, for use with BOL cost annotations
[Deploy: scenario[Name("staging"), Cost("Cores", 2), Cost("Memory", 700), Param("c", Default("\\\"Customer X\\\"")), Param("staging", Default("True")), Param("da", Req)] ]
[Deploy: scenario[Name("live"), Cost("Cores", 1), Cost("Memory", 300), Param("c", Default("\\\"Customer X\\\"")), Param("staging", Default("False")), Param("da", Req)] ]
// tofixJAC: add staging parameter
class QueryServiceImpl(DeploymentAgent da, Customer c, Bool staging) implements IQueryService {
	Int reqCount = 0;
	State currentState = STOP;
	Id serviceId = 0;
	
	Response invoke(Request request) {
		assert currentState == RUNNING;
                println(toString(now()) + ": invoking query with cost " + toString(request));

		[Cost: cost(request)] reqCount = reqCount+1;
		return True;
	}

	Unit setStatus(State status) {
		currentState = status;
	}

	State getStatus() {
		return currentState;
	}
	
	Id getServiceId() {
		return serviceId;
	}

	Unit setServiceId(Id id) {
		// ensure serviceId is set only once
		assert serviceId == 0;

		serviceId = id;
	}

	ServiceType getServiceType(){
		return FAS;
	}

	Customer getCustomer() {
		return c;
	}

	Int getLatency() {
		return 0;
	}

	Int getRequestCount() {
		return reqCount;
	}

	Int getCPU() {
		DeploymentComponent dc = thisDC();
		Fut<InfRat> fdt = dc!total(Speed);
		InfRat dt = fdt.get;
		return truncate(finvalue(dt));
	}
	
	Int getBandwidth() {
		DeploymentComponent dc = thisDC();
		Fut<InfRat> fdt = dc!total(Bandwidth);
		InfRat dt = fdt.get;
		return truncate(finvalue(dt));
	}
	
	Int getMemory() {
		DeploymentComponent dc = thisDC();
		Fut<InfRat> fdt = dc!total(Memory);
		InfRat dt = fdt.get;
		return truncate(finvalue(dt));
	}
	
	InfRat getResource(Resourcetype t) {
		DeploymentComponent dc = thisDC();
		Fut<InfRat> fdt = dc!total(t);
		InfRat dt = fdt.get;
		return dt;
	}
	
	List<Item> doQuery(String q) {
		return Nil;
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////

interface MonitoringQueryEndpoint extends EndPoint {
	[RESTCallable] Unit invokeWithSize(Int proctime, Int amazonECU);
}

class MonitoringQueryEndpointImpl(List<EndPoint> allEndpoints, DegradationMonitorIf monitor)
   implements MonitoringQueryEndpoint {
	List<EndPoint> current = allEndpoints;
	State state = RUNNING;

	/* DNS (round robin) balancing over endpoints */
	Response invoke(Request request) {
		assert state != STOP;
		if (current == Nil) {
			current = allEndpoints;
		}
		EndPoint p = head(current);
		current = tail(current);
		return await p!invoke(request);
	}

	Unit setStatus(State status) {
		state = status;
	}

	State getStatus() {
		return state;
	}

	Unit invokeWithSize(Int proctime, Int amazonECU) {
		//calculate query cost
		Request req = proctime * amazonECU;

		// invoke service with cost
		Time start = now();
		this.invoke(req);
		Time end = now();

		//calculate new proctime
		Rat newProcTime = timeValue(end) - timeValue(start);
		println("new cost: " + toString(newProcTime));

		//register measurement to the monitor
		monitor.notify_query(start, newProcTime);
	}
}



type CustomerConfig = Pair<Customer, List<Pair<Config, Int>>>;


// functions that using the cloudAPI can retreive the name of the instance of
// the DC
def List<Int> getHyphenPosition(String s, Int v) =
	if s == "" then
    Nil
  else
		if substr(s,0,1) == "-"
		then
			Cons(v,getHyphenPosition(substr(s,1,strlen(s)-1), v+1))
		else
			getHyphenPosition(substr(s,1,strlen(s)-1), v+1);

// return the instance name when it is invoked with the string obtained by DC.getname()
def String getInstanceName(String s) =
	let (List<Int> ls) = (getHyphenPosition(s,0)) in
		if length(ls) > 1 then substr(s,head(ls)+1,head(tail(ls))-head(ls)-1) else s;

def Bool strContains(String s, String substring) =
	let (Int l1) = (strlen(s)) in
		let (Int l2) = (strlen(substring)) in
			if (l2 > l1)
			then
			  False
			else
				if (substr(s,0,l2) == substring)
				then
					True
				else
					strContains(substr(s,1,l1-1),substring);


def List<A> filter_lists_by_substr<A>(List<A> xs, List<String> ys, String substring) =
	case ys {
		Nil => Nil; 
		Cons(z, zs) =>
			if strContains(z,substring)
			then
				Cons(head(xs),filter_lists_by_substr(tail(xs),zs,substring))
			else
				filter_lists_by_substr(tail(xs),zs,substring);
	};


def List<A> fst_list<A,B>(List<Pair<A,B>> ls) =
	case ls { 
     Nil => Nil; 
     Cons(x, xs) => Cons(fst(x),fst_list(xs));  
  };

def List<B> snd_list<A,B>(List<Pair<A,B>> ls) =
	case ls { 
     Nil => Nil; 
     Cons(x, xs) => Cons(snd(x),snd_list(xs));  
  };	
		

interface UtilityFunctions {
	List<String> getdc_instance_names(List<DeploymentComponent> ls);
}

class UtilityFunctionsImpl() implements UtilityFunctions {

	List<String> getdc_instance_names(List<DeploymentComponent> ls) {
		List<String> rs = Nil;
		while (ls != Nil) {
			DeploymentComponent dc = head(ls);
			String s = dc.getName();
			s = getInstanceName(s);
			rs = Cons(s,rs);
			ls = tail(ls);
		}
		return reverse(rs);
	}
}




/** JSON ANNOTATION
{  
  "id":"AddQueryDeployer",
  "specification":"(sum ?x in '.*us.': ?x.QueryServiceImpl['live']) = 2 and (forall ?x in DC: ( ?x.QueryServiceImpl['.*'] < 2 and ( ?x.QueryServiceImpl['.*'] = 1 impl ?x.DeploymentAgentImpl = 1))) and abs((sum ?x in '.*_us2': ?x.QueryServiceImpl['.*']) - (sum ?x in '.*_us1': ?x.QueryServiceImpl['.*']) ) = 0 and (sum ?x in 'c.*': ?x.QueryServiceImpl['.*'] = 0) and (sum ?x in 'm.*': ?x.LoadBalancerEndPointImpl = 0) and (sum ?x in 'm.*': ?x.LoadBalancerServiceImpl = 0) and (sum ?x in 'm.*': ?x.PlatformServiceImpl = 0)",
  "DC":[  

  ],
  "obj":[  
    {  
      "name":"platformServiceObjEu",
      "provides":[  
        {  
          "ports":[  
            "MonitorPlatformService",
            "PlatformService"
          ],
          "num":-1
        }
      ],
      "may_add_reference_to":[  
        {  
          "interface":"Service",
          "method":"addServiceInstance",
          "DC_as_additional_parameter":false
        }
      ],
      "interface":"MonitorPlatformService"
    },
    {  
      "name":"platformServiceObjUs",
      "provides":[  
        {  
          "ports":[  
            "MonitorPlatformService",
            "PlatformService"
          ],
          "num":-1
        }
      ],
      "may_add_reference_to":[  
        {  
          "interface":"Service",
          "method":"addServiceInstance",
          "DC_as_additional_parameter":false
        }
      ],
      "interface":"MonitorPlatformService"
    },
    {  
      "name":"deploymentServiceObjEu",
      "provides":[  

      ],
      "may_add_reference_to":[  
        {  
          "interface":"DeploymentAgent",
          "method":"add",
          "DC_as_additional_parameter":false
        }
      ],
      "interface":"DeploymentService"
    },
    {  
      "name":"deploymentServiceObjUs",
      "provides":[  

      ],
      "may_add_reference_to":[  
        {  
          "interface":"DeploymentAgent",
          "method":"add",
          "DC_as_additional_parameter":false
        }
      ],
      "interface":"DeploymentService"
    },
    {  
      "name":"loadBalancerEndPointObjEu1",
      "provides":[  
        {  
          "ports":[  
            "LoadBalancerEndPoint"
          ],
          "num":-1
        }
      ],
      "may_add_reference_to":[  
        {  
          "interface":"Service",
          "method":"add",
          "DC_as_additional_parameter":false
        }
      ],
      "interface":"LoadBalancerEndPoint"
    },
    {  
      "name":"loadBalancerEndPointObjUs1",
      "provides":[  
        {  
          "ports":[  
            "LoadBalancerEndPoint"
          ],
          "num":-1
        }
      ],
      "may_add_reference_to":[  
        {  
          "interface":"Service",
          "method":"add",
          "DC_as_additional_parameter":false
        }
      ],
      "interface":"LoadBalancerEndPoint"
    },
    {  
      "name":"loadBalancerEndPointObjUs2",
      "provides":[  
        {  
          "ports":[  
            "LoadBalancerEndPoint"
          ],
          "num":-1
        }
      ],
      "may_add_reference_to":[  
        {  
          "interface":"Service",
          "method":"add",
          "DC_as_additional_parameter":false
        }
      ],
      "interface":"LoadBalancerEndPoint"
    }
  ],
  "bind preferences":[  
    "local",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_eu' :  exists ?y of type platformServiceObjEu in DC : ?x used by ?y",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  exists ?y of type platformServiceObjUs in DC : ?x used by ?y",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_eu' :  exists ?y of type loadBalancerEndPointObjEu1 in DC : ?x used by ?y",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  exists ?y of type loadBalancerEndPointObjUs1 in DC : ?x used by ?y",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  exists ?y of type loadBalancerEndPointObjUs2 in DC : ?x used by ?y",
    "sum ?x of type DeploymentAgentImpl in '.*_eu' :  exists ?y of type deploymentServiceObjEu in DC : ?x used by ?y",
    "sum ?x of type DeploymentAgentImpl in '.*_us.' :  exists ?y of type deploymentServiceObjUs in DC : ?x used by ?y"
  ],
  "add_method_priorities":[  
    {  
      "class":"loadBalancerEndPointObjEu1",
      "method":"add"
    },
    {  
      "class":"loadBalancerEndPointObjUs1",
      "method":"add"
    },
    {  
      "class":"loadBalancerEndPointObjUs2",
      "method":"add"
    },
    {  
      "class":"platformServiceObjEu",
      "method":"addServiceInstance"
    },
    {  
      "class":"platformServiceObjUs",
      "method":"addServiceInstance"
    },
		{  
      "class":"DeploymentAgentImpl",
      "method":"install"
    },
    {  
      "class":"deploymentServiceObjEu",
      "method":"add"
    },
    {  
      "class":"deploymentServiceObjUs",
      "method":"add"
    }
  ]
}
**/

	[ SmartDeploy : "{\"id\":\"AddQueryDeployer\",\"specification\":\"(sum ?x in '.*us.': ?x.QueryServiceImpl['live']) = 2 and (forall ?x in DC: ( ?x.QueryServiceImpl['.*'] < 2 and ( ?x.QueryServiceImpl['.*'] = 1 impl ?x.DeploymentAgentImpl = 1))) and abs((sum ?x in '.*_us2': ?x.QueryServiceImpl['.*']) - (sum ?x in '.*_us1': ?x.QueryServiceImpl['.*']) ) = 0 and (sum ?x in 'c.*': ?x.QueryServiceImpl['.*'] = 0) and (sum ?x in 'm.*': ?x.LoadBalancerEndPointImpl = 0) and (sum ?x in 'm.*': ?x.LoadBalancerServiceImpl = 0) and (sum ?x in 'm.*': ?x.PlatformServiceImpl = 0)\",\"DC\":[],\"obj\":[{\"name\":\"platformServiceObjEu\",\"provides\":[{\"ports\":[\"MonitorPlatformService\",\"PlatformService\"],\"num\":-1}],\"may_add_reference_to\":[{\"interface\":\"Service\",\"method\":\"addServiceInstance\",\"DC_as_additional_parameter\":false}],\"interface\":\"MonitorPlatformService\"},{\"name\":\"platformServiceObjUs\",\"provides\":[{\"ports\":[\"MonitorPlatformService\",\"PlatformService\"],\"num\":-1}],\"may_add_reference_to\":[{\"interface\":\"Service\",\"method\":\"addServiceInstance\",\"DC_as_additional_parameter\":false}],\"interface\":\"MonitorPlatformService\"},{\"name\":\"deploymentServiceObjEu\",\"provides\":[],\"may_add_reference_to\":[{\"interface\":\"DeploymentAgent\",\"method\":\"add\",\"DC_as_additional_parameter\":false}],\"interface\":\"DeploymentService\"},{\"name\":\"deploymentServiceObjUs\",\"provides\":[],\"may_add_reference_to\":[{\"interface\":\"DeploymentAgent\",\"method\":\"add\",\"DC_as_additional_parameter\":false}],\"interface\":\"DeploymentService\"},{\"name\":\"loadBalancerEndPointObjEu1\",\"provides\":[{\"ports\":[\"LoadBalancerEndPoint\"],\"num\":-1}],\"may_add_reference_to\":[{\"interface\":\"Service\",\"method\":\"add\",\"DC_as_additional_parameter\":false}],\"interface\":\"LoadBalancerEndPoint\"},{\"name\":\"loadBalancerEndPointObjUs1\",\"provides\":[{\"ports\":[\"LoadBalancerEndPoint\"],\"num\":-1}],\"may_add_reference_to\":[{\"interface\":\"Service\",\"method\":\"add\",\"DC_as_additional_parameter\":false}],\"interface\":\"LoadBalancerEndPoint\"},{\"name\":\"loadBalancerEndPointObjUs2\",\"provides\":[{\"ports\":[\"LoadBalancerEndPoint\"],\"num\":-1}],\"may_add_reference_to\":[{\"interface\":\"Service\",\"method\":\"add\",\"DC_as_additional_parameter\":false}],\"interface\":\"LoadBalancerEndPoint\"}],\"bind preferences\":[\"local\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_eu' :  exists ?y of type platformServiceObjEu in DC : ?x used by ?y\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  exists ?y of type platformServiceObjUs in DC : ?x used by ?y\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_eu' :  exists ?y of type loadBalancerEndPointObjEu1 in DC : ?x used by ?y\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  exists ?y of type loadBalancerEndPointObjUs1 in DC : ?x used by ?y\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  exists ?y of type loadBalancerEndPointObjUs2 in DC : ?x used by ?y\",\"sum ?x of type DeploymentAgentImpl in '.*_eu' :  exists ?y of type deploymentServiceObjEu in DC : ?x used by ?y\",\"sum ?x of type DeploymentAgentImpl in '.*_us.' :  exists ?y of type deploymentServiceObjUs in DC : ?x used by ?y\"],\"add_method_priorities\":[{\"class\":\"loadBalancerEndPointObjEu1\",\"method\":\"add\"},{\"class\":\"loadBalancerEndPointObjUs1\",\"method\":\"add\"},{\"class\":\"loadBalancerEndPointObjUs2\",\"method\":\"add\"},{\"class\":\"platformServiceObjEu\",\"method\":\"addServiceInstance\"},{\"class\":\"platformServiceObjUs\",\"method\":\"addServiceInstance\"},{\"class\":\"DeploymentAgentImpl\",\"method\":\"install\"},{\"class\":\"deploymentServiceObjEu\",\"method\":\"add\"},{\"class\":\"deploymentServiceObjUs\",\"method\":\"add\"}]}" ]

class AddQueryServicesDeployerImpl(
						CloudProvider cloudProvider,
						MonitorPlatformService platformServiceObjEu,
						MonitorPlatformService platformServiceObjUs,
						DeploymentService deploymentServiceObjEu,
						DeploymentService deploymentServiceObjUs,
						LoadBalancerEndPoint loadBalancerEndPointObjEu1,
						LoadBalancerEndPoint loadBalancerEndPointObjUs1,
						LoadBalancerEndPoint loadBalancerEndPointObjUs2) implements DeployerIF {
	
	List<SmartDeployInterface> depl_list = Nil;
	
	Unit scaleUp() {
		SmartDeployInterface d = new AddQueryDeployer(
			cloudProvider,
			platformServiceObjEu,
			platformServiceObjUs,
			deploymentServiceObjEu,
			deploymentServiceObjUs,
			loadBalancerEndPointObjEu1,
			loadBalancerEndPointObjUs1,
			loadBalancerEndPointObjUs2);
		depl_list = Cons(d,depl_list);
		d.deploy();
	}

	Unit scaleDown() {
		if (depl_list != Nil) {
			SmartDeployInterface d = head(depl_list);
			depl_list = tail(depl_list);
			d.undeploy();
		}
	}
}





/******************
******MAIN*********
******************/

/*
{  
  "c4_xlarge_us1":{  
    "cost":209,
    "resources":{  
      "Cores":4,
      "Memory":750
    }
  },
  "c4_2xlarge_us1":{  
    "cost":419,
    "resources":{  
      "Cores":8,
      "Memory":1500
    }
  },
  "m4_xlarge_us1":{  
    "cost":239,
    "resources":{  
      "Cores":4,
      "Memory":1600
    }
  },
  "m4_large_us1":{  
    "cost":120,
    "resources":{  
      "Cores":2,
      "Memory":800
    }
  },
	"c4_xlarge_us2":{  
    "cost":209,
    "resources":{  
      "Cores":4,
      "Memory":750
    }
  },
  "c4_2xlarge_us2":{  
    "cost":419,
    "resources":{  
      "Cores":8,
      "Memory":1500
    }
  },
  "m4_xlarge_us2":{  
    "cost":239,
    "resources":{  
      "Cores":4,
      "Memory":1600
    }
  },
  "m4_large_us2":{  
    "cost":120,
    "resources":{  
      "Cores":2,
      "Memory":800
    }
  },
	"c4_xlarge_eu":{  
    "cost":209,
    "resources":{  
      "Cores":4,
      "Memory":750
    }
  },
  "c4_2xlarge_eu":{  
    "cost":419,
    "resources":{  
      "Cores":8,
      "Memory":1500
    }
  },
  "m4_xlarge_eu":{  
    "cost":239,
    "resources":{  
      "Cores":4,
      "Memory":1600
    }
  },
  "m4_large_eu":{  
    "cost":120,
    "resources":{  
      "Cores":2,
      "Memory":800
    }
  }
}
*/



{


  [SmartDeployCloudProvider: "{\"c4_xlarge_us1\":{\"cost\":209,\"resources\":{\"Cores\":4,\"Memory\":750}},\"c4_2xlarge_us1\":{\"cost\":419,\"resources\":{\"Cores\":8,\"Memory\":1500}},\"m4_xlarge_us1\":{\"cost\":239,\"resources\":{\"Cores\":4,\"Memory\":1600}},\"m4_large_us1\":{\"cost\":120,\"resources\":{\"Cores\":2,\"Memory\":800}},\"c4_xlarge_us2\":{\"cost\":209,\"resources\":{\"Cores\":4,\"Memory\":750}},\"c4_2xlarge_us2\":{\"cost\":419,\"resources\":{\"Cores\":8,\"Memory\":1500}},\"m4_xlarge_us2\":{\"cost\":239,\"resources\":{\"Cores\":4,\"Memory\":1600}},\"m4_large_us2\":{\"cost\":120,\"resources\":{\"Cores\":2,\"Memory\":800}},\"c4_xlarge_eu\":{\"cost\":209,\"resources\":{\"Cores\":4,\"Memory\":750}},\"c4_2xlarge_eu\":{\"cost\":419,\"resources\":{\"Cores\":8,\"Memory\":1500}},\"m4_xlarge_eu\":{\"cost\":239,\"resources\":{\"Cores\":4,\"Memory\":1600}},\"m4_large_eu\":{\"cost\":120,\"resources\":{\"Cores\":2,\"Memory\":800}}}"]
  CloudProvider cp = new CloudProvider("CloudProvider");
	cp.addSmartDeployInstances();
	
	
/** JSON ANNOTATION
{  
  "id":"MainSmartDeployer",
  "specification":"(sum ?x in '.*_us.': ?x.QueryServiceImpl['staging']) > 0 and (sum ?x in '.*_eu': ?x.QueryServiceImpl['staging']) > 0 and QueryServiceImpl['.*'] = 4 and (sum ?x in '.*_us.': ?x.LoadBalancerServiceImpl) = 1 and (sum ?x in '.*_eu': ?x.LoadBalancerServiceImpl) = 1 and (sum ?x in '.*_us.': ?x.PlatformServiceImpl) = 1 and (sum ?x in '.*_eu': ?x.PlatformServiceImpl) = 1 and (sum ?x in '.*_us1': ?x.LoadBalancerEndPointImpl) = 1 and (sum ?x in '.*_us2': ?x.LoadBalancerEndPointImpl) = 1 and (sum ?x in '.*_eu': ?x.LoadBalancerEndPointImpl) = 1 and (sum ?x in '.*_us.': ?x.DeploymentServiceImpl) = 1 and (sum ?x in '.*_eu': ?x.DeploymentServiceImpl) = 1 and (forall ?x in DC: ( ?x.QueryServiceImpl['.*'] < 2 and ( ?x.QueryServiceImpl['.*'] = 1 impl ?x.DeploymentAgentImpl = 1) and ( ?x.PlatformServiceImpl > 0 impl  ((?x.LoadBalancerServiceImpl = 1) and (?x.DeploymentServiceImpl = 1) and (sum ?y in obj:  ?x.?y) = 3)) and (?x.LoadBalancerEndPointImpl > 0 impl (sum ?y in obj: ?x.?y) = 1) ))  and (sum ?x in '.*_us2': ?x.QueryServiceImpl['.*']) = (sum ?x in '.*_us1': ?x.QueryServiceImpl['.*']) and (sum ?x in 'c.*': ?x.QueryServiceImpl['.*'] = 0) and (sum ?x in 'm.*': ?x.LoadBalancerEndPointImpl = 0) and (sum ?x in 'm.*': ?x.LoadBalancerServiceImpl = 0) and (sum ?x in 'm.*': ?x.PlatformServiceImpl = 0)",
  "DC":[  

  ],
  "obj":[  

  ],
  "cloud_provider_DC_availability":{  
    "c4_2xlarge_us2":2,
    "c4_2xlarge_us1":2,
    "m4_large_us2":2,
    "m4_large_us1":2,
    "c4_xlarge_us2":2,
    "c4_xlarge_us1":2,
    "m4_xlarge_us2":2,
    "m4_xlarge_us1":2,
    "c4_2xlarge_eu":2,
    "c4_xlarge_eu":2,
    "m4_large_eu":2,
    "m4_xlarge_eu":2
  },
  "bind preferences":[  
    "local",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_eu' :  forall ?y of type LoadBalancerEndPointImpl in '.*_eu' : ?x used by ?y",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  forall ?y of type LoadBalancerEndPointImpl in '.*_us.' : ?x used by ?y",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_eu' :  forall ?y of type PlatformServiceImpl in '.*_eu' : ?x used by ?y",
    "sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  forall ?y of type PlatformServiceImpl in '.*_us.' : ?x used by ?y",
    "sum ?x of type LoadBalancerEndPointImpl['.*'] in '.*_eu' :  exists ?y of type PlatformServiceImpl in '.*_eu' : ?x used by ?y",
    "sum ?x of type LoadBalancerEndPointImpl['.*'] in '.*_us.' :  exists ?y of type PlatformServiceImpl in '.*_us.' : ?x used by ?y",
    "sum ?x of type LoadBalancerEndPointImpl in '.*_eu' :  exists ?y of type LoadBalancerServiceImpl in '.*_eu' : ?x used by ?y",
    "sum ?x of type LoadBalancerEndPointImpl in '.*_us.' :  exists ?y of type LoadBalancerServiceImpl in '.*_us.' : ?x used by ?y",
    "sum ?x of type DeploymentAgentImpl in '.*_eu' :  exists ?y of type DeploymentServiceImpl in '.*_eu' : ?x used by ?y",
    "sum ?x of type DeploymentAgentImpl in '.*_us.' :  exists ?y of type DeploymentServiceImpl in '.*_us.' : ?x used by ?y"
  ],
  "add_method_priorities":[  
    {  
      "class":"PlatformServiceImpl",
      "method":"addEndPoint"
    },		
    {  
      "class":"LoadBalancerEndPointImpl",
      "method":"add"
    },
		{  
      "class":"PlatformServiceImpl",
      "method":"addServiceInstance"
    },
		{  
      "class":"DeploymentAgentImpl",
      "method":"install"
    },
    {  
      "class":"DeploymentServiceImpl",
      "method":"add"
    }
  ]
}
**/


	[ SmartDeploy : "{\"id\":\"MainSmartDeployer\",\"specification\":\"(sum ?x in '.*_us.': ?x.QueryServiceImpl['staging']) > 0 and (sum ?x in '.*_eu': ?x.QueryServiceImpl['staging']) > 0 and QueryServiceImpl['.*'] = 4 and (sum ?x in '.*_us.': ?x.LoadBalancerServiceImpl) = 1 and (sum ?x in '.*_eu': ?x.LoadBalancerServiceImpl) = 1 and (sum ?x in '.*_us.': ?x.PlatformServiceImpl) = 1 and (sum ?x in '.*_eu': ?x.PlatformServiceImpl) = 1 and (sum ?x in '.*_us1': ?x.LoadBalancerEndPointImpl) = 1 and (sum ?x in '.*_us2': ?x.LoadBalancerEndPointImpl) = 1 and (sum ?x in '.*_eu': ?x.LoadBalancerEndPointImpl) = 1 and (sum ?x in '.*_us.': ?x.DeploymentServiceImpl) = 1 and (sum ?x in '.*_eu': ?x.DeploymentServiceImpl) = 1 and (forall ?x in DC: ( ?x.QueryServiceImpl['.*'] < 2 and ( ?x.QueryServiceImpl['.*'] = 1 impl ?x.DeploymentAgentImpl = 1) and ( ?x.PlatformServiceImpl > 0 impl  ((?x.LoadBalancerServiceImpl = 1) and (?x.DeploymentServiceImpl = 1) and (sum ?y in obj:  ?x.?y) = 3)) and (?x.LoadBalancerEndPointImpl > 0 impl (sum ?y in obj: ?x.?y) = 1) ))  and (sum ?x in '.*_us2': ?x.QueryServiceImpl['.*']) = (sum ?x in '.*_us1': ?x.QueryServiceImpl['.*']) and (sum ?x in 'c.*': ?x.QueryServiceImpl['.*'] = 0) and (sum ?x in 'm.*': ?x.LoadBalancerEndPointImpl = 0) and (sum ?x in 'm.*': ?x.LoadBalancerServiceImpl = 0) and (sum ?x in 'm.*': ?x.PlatformServiceImpl = 0)\",\"DC\":[],\"obj\":[],\"cloud_provider_DC_availability\":{\"c4_2xlarge_us2\":2,\"c4_2xlarge_us1\":2,\"m4_large_us2\":2,\"m4_large_us1\":2,\"c4_xlarge_us2\":2,\"c4_xlarge_us1\":2,\"m4_xlarge_us2\":2,\"m4_xlarge_us1\":2,\"c4_2xlarge_eu\":2,\"c4_xlarge_eu\":2,\"m4_large_eu\":2,\"m4_xlarge_eu\":2},\"bind preferences\":[\"local\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_eu' :  forall ?y of type LoadBalancerEndPointImpl in '.*_eu' : ?x used by ?y\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  forall ?y of type LoadBalancerEndPointImpl in '.*_us.' : ?x used by ?y\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_eu' :  forall ?y of type PlatformServiceImpl in '.*_eu' : ?x used by ?y\",\"sum ?x of type QueryServiceImpl['.*'] in '.*_us.' :  forall ?y of type PlatformServiceImpl in '.*_us.' : ?x used by ?y\",\"sum ?x of type LoadBalancerEndPointImpl['.*'] in '.*_eu' :  exists ?y of type PlatformServiceImpl in '.*_eu' : ?x used by ?y\",\"sum ?x of type LoadBalancerEndPointImpl['.*'] in '.*_us.' :  exists ?y of type PlatformServiceImpl in '.*_us.' : ?x used by ?y\",\"sum ?x of type LoadBalancerEndPointImpl in '.*_eu' :  exists ?y of type LoadBalancerServiceImpl in '.*_eu' : ?x used by ?y\",\"sum ?x of type LoadBalancerEndPointImpl in '.*_us.' :  exists ?y of type LoadBalancerServiceImpl in '.*_us.' : ?x used by ?y\",\"sum ?x of type DeploymentAgentImpl in '.*_eu' :  exists ?y of type DeploymentServiceImpl in '.*_eu' : ?x used by ?y\",\"sum ?x of type DeploymentAgentImpl in '.*_us.' :  exists ?y of type DeploymentServiceImpl in '.*_us.' : ?x used by ?y\"],\"add_method_priorities\":[{\"class\":\"PlatformServiceImpl\",\"method\":\"addEndPoint\"},{\"class\":\"LoadBalancerEndPointImpl\",\"method\":\"add\"},{\"class\":\"PlatformServiceImpl\",\"method\":\"addServiceInstance\"},{\"class\":\"DeploymentAgentImpl\",\"method\":\"install\"},{\"class\":\"DeploymentServiceImpl\",\"method\":\"add\"}]}" ]

	SmartDeployInterface c1 = new MainSmartDeployer(cp);
	println("after new MainSmartDeployer");
	c1.deploy();
	println("after deploy");


	List<Pair<MonitorPlatformService,DeploymentComponent>> monitorPlatformServices_aux = c1.getMonitorPlatformService();
	List<Pair<DeploymentService,DeploymentComponent>> deploymentServices_aux  = c1.getDeploymentService();
	List<Pair<LoadBalancerEndPoint,DeploymentComponent>> loadBalancerEndPoints_aux = c1.getLoadBalancerEndPoint();

	UtilityFunctions utility_obj = new UtilityFunctionsImpl(); // just to use the method getdc_instance_names
	List<String> string_list = Nil;
	List<DeploymentComponent> dc_list = Nil;

	List<MonitorPlatformService> monitorPlatformServices = fst_list(monitorPlatformServices_aux);
	dc_list = snd_list(monitorPlatformServices_aux);
	string_list = utility_obj.getdc_instance_names(dc_list);
	List<MonitorPlatformService> monitorPlatformServicesUs = filter_lists_by_substr(monitorPlatformServices,string_list,"_us");
	List<MonitorPlatformService> monitorPlatformServicesEu = filter_lists_by_substr(monitorPlatformServices,string_list,"_eu");

	List<DeploymentService> deploymentServices = fst_list(deploymentServices_aux);
	dc_list = snd_list(deploymentServices_aux);
	string_list = utility_obj.getdc_instance_names(dc_list);
	List<DeploymentService> deploymentServicesUs = filter_lists_by_substr(deploymentServices,string_list,"_us");
	List<DeploymentService> deploymentServicesEu = filter_lists_by_substr(deploymentServices,string_list,"_eu");

	List<LoadBalancerEndPoint> loadBalancerEndPoints = fst_list(loadBalancerEndPoints_aux);
	dc_list = snd_list(loadBalancerEndPoints_aux);
	string_list = utility_obj.getdc_instance_names(dc_list);
	List<LoadBalancerEndPoint> loadBalancerEndPointsUs = filter_lists_by_substr(loadBalancerEndPoints,string_list,"_us");
	List<LoadBalancerEndPoint> loadBalancerEndPointsEu = filter_lists_by_substr(loadBalancerEndPoints,string_list,"_eu");

	DeployerIF deployerif = new AddQueryServicesDeployerImpl(
						cp,
						head(monitorPlatformServicesEu),
						head(monitorPlatformServicesUs),
						head(deploymentServicesUs),
						head(deploymentServicesEu),
						head(loadBalancerEndPointsEu),
						head(loadBalancerEndPointsUs),
						head(tail(loadBalancerEndPointsUs)));	
	

	// create monitoring service
	MonitoringService ms = new MonitoringServiceImpl();

	//create Service degradation monitor and register with monitoring service
	DegradationMonitorIf degradationMonitor = new DegradationMonitorImpl(deployerif);
	//Fut<Unit> df = ms!add(Rule(10, degradationMonitor)); df.get;

	//create monitoring endpoint
	MonitoringQueryEndpoint mqep =
		new MonitoringQueryEndpointImpl(loadBalancerEndPoints, degradationMonitor);

	print("FRH model simulation terminated\n");


}

// Local Variables:
// abs-use-timed-interpreter: t
// End:
